@load base/frameworks/sumstats
@load base/protocols/dns
@load base/utils/urls
@load base/init-bare
@load base/protocols/dhcp/main
@load base/utils/addrs.bro
@load base/bif/bro.bif.bro

0# This program records the following 14 parameter for every unique (SrcIP,Domain) pair

redef enum Log::ID += { LOG };

type new_features: record {
    srcAddr: addr &log;
    domain: string &log;
    URL: string &log &optional;
    URL_query_names: set[string] &log;
    URL_query_values: set[string] &log;
    URL_path: set[string] &log;
    URL_path_length: count &default = 0;
    number_of_URL_query_parameters: count &log &default = 0 &optional;
    filename: set[string] &log;
    filename_length: count &log &optional;
    interarrival_time: interval &log &optional;
    number_of_flows: count &log &optional;
    number_of_downloaded_bytes: count &log &optional &default = 0;
    number_of_uploaded_bytes: count &log &optional &default = 0;  
    server_IP_address: addr &log &optional;
    hostname: string &log &optional;
};

# Collect and record data for a unique (src, domain) pair ie., domain based feature collection
# domain_ip_mapping maps a single domain to multiple IPs: one-to-many mapping
global rec_list: table[addr,string] of new_features;
global inter_arr_time: table[addr,string] of vector of time;
global domain_ip_mapping: table[string] of set[addr];

# Returns the domain to which the given IP belongs to, based on the Domain-IP mapping
function get_domain(dest: addr): string {
    for ([trg] in domain_ip_mapping){
        if(dest in domain_ip_mapping[trg]){
            return trg;
        }
    }
    return "";
}

# Triggered everytime a DNS request-response is made
# Updates the domain_ip_mapping 
event DNS::log_dns(rec: DNS::Info){
    if(rec?$query){
        if(rec$query in domain_ip_mapping){
        if(rec?$answers){
            for (i in rec$answers){
                if(is_valid_ip(rec$answers[i])){
                    add domain_ip_mapping[rec$query][to_addr(rec$answers[i])];
                }
            }
        }
        }
        else{
            local dom: set[addr];
            if(rec?$answers){
            for (i in rec$answers){
                if(is_valid_ip(rec$answers[i])){
                    add dom[to_addr(rec$answers[i])];
                }
            }
            }
            domain_ip_mapping[rec$query]=dom;
        }
    }
}

event bro_init(){
	Log::create_stream(LOG, [$columns=new_features, $path="new_features_domain"]);
    # local r1 = SumStats::Reducer($stream="avg_fo",$apply=set(SumStats::SUM));
}

event http_request(c: connection, method: string, original_URI: string, unescaped_URI: string, version: string){
    local rec1: URI;
    local sender_ip = c$id$orig_h;
    local dest_ip = c$id$resp_h;
    local domain : string;
    domain=get_domain(dest_ip);

    local dest_url = original_URI;
    if([sender_ip,domain] in rec_list){
        local rec3: new_features= rec_list[sender_ip,domain];
        if (dest_url != "") {
        rec1=decompose_uri(dest_url);
        if(rec1?$params){
        for (name in rec1$params){
            add rec3$URL_query_names[name];
            add rec3$URL_query_values[rec1$params[name]];
        }
        add rec3$URL_path[rec1$path];
        if(rec1?$file_name){
            add rec3$filename[rec1$file_name];
        }
        }
        }
        rec3$number_of_downloaded_bytes+=c$resp$num_bytes_ip;
        rec3$number_of_uploaded_bytes+=c$orig$num_bytes_ip;
        inter_arr_time[sender_ip,domain][|inter_arr_time[sender_ip,domain]|]=c$start_time;
        rec3$number_of_flows+=1;
        
        rec_list[sender_ip,domain]=rec3;
    }
    else{
        local rec2: new_features;
        local inter: vector of time;
        rec2$srcAddr=sender_ip;
        rec2$domain=domain;
        if (dest_url != "") {
        rec1=decompose_uri(dest_url);
        rec2$URL=dest_url;
        if(rec1?$params){
        for (name in rec1$params){
            add rec2$URL_query_names[name];
            add rec2$URL_query_values[rec1$params[name]];
        }
        add rec2$URL_path[rec1$path];
        if(rec1?$file_name){
            add rec2$filename[rec1$file_name];
        }
        }
        }
        rec2$number_of_downloaded_bytes=c$resp$num_bytes_ip;
        rec2$number_of_uploaded_bytes=c$orig$num_bytes_ip;
        rec2$number_of_flows=1;
        inter[|inter|]=c$start_time;
        inter_arr_time[sender_ip,domain]=inter;
        rec_list[sender_ip,domain]=rec2;
    }    
}

event connection_reused(c: connection) {
    local rec1: URI;
    local sender_ip = c$id$orig_h;
    local dest_ip = c$id$resp_h;
    local domain : string;
    domain=get_domain(dest_ip);
    
    if([sender_ip,domain] in rec_list){
        local rec3 = rec_list[sender_ip,domain];
        rec3$number_of_downloaded_bytes+=c$resp$num_bytes_ip;
        rec3$number_of_uploaded_bytes+=c$orig$num_bytes_ip;
        rec3$number_of_flows+=1;
        inter_arr_time[sender_ip,domain][|inter_arr_time[sender_ip,domain]|]=c$start_time;
        rec_list[sender_ip,domain]=rec3;
    }
    else{
        local rec2: new_features;
        local inter: vector of time;
        rec2$srcAddr=sender_ip;
        rec2$domain=domain;
        rec2$number_of_downloaded_bytes=c$resp$num_bytes_ip;
        rec2$number_of_uploaded_bytes=c$orig$num_bytes_ip;
        rec2$number_of_flows=1;
        inter[|inter|]=c$start_time;
        inter_arr_time[sender_ip,domain]=inter;
        rec_list[sender_ip,domain]=rec2;
    }
}
# To be used for the parameters ServerIP and Hostname 
# event DHCP::log_dhcp(c: DHCP::Info){ #event DNS::log_dns(c: DNS::Info)
#     for ([sender_ip,domain] in rec_list){
#     	if(c?$assigned_addr){
#         if(sender_ip == c$assigned_addr){
#             rec_list[sender_ip,domain]$hostname=c$host_name;
#             rec_list[sender_ip,domain]$server_IP_address=c$server_addr;
#         }
#         }
#     }
# }
event bro_done(){

    for ([sender_ip,domain] in rec_list){
        local rec1 = rec_list[sender_ip,domain];
        if(rec1?$URL_path){
        rec1$URL_path_length=|rec1$URL_path|;
        rec1$number_of_URL_query_parameters=|rec1$URL_query_names|;
        rec1$filename_length=|rec1$filename|;
        }
        local diff: interval;
        diff=0sec;
        for ([i] in inter_arr_time[sender_ip,domain]){
            if(i != 0){                
                diff+=inter_arr_time[sender_ip,domain][i]-inter_arr_time[sender_ip,domain][i-1];
            }
        }
        diff=diff/|inter_arr_time[sender_ip,domain]|;
        rec1$interarrival_time=diff;
        Log::write( LOG, rec1);
    }
	
}
